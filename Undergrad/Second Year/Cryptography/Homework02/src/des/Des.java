package des;
import main.Utility;

/**
 * A class describing DES.
 * Encryption: takes a plaintext bitstring of length 64 and it's using a key of length 56,
 * obtaining a ciphertext of length 64. 
 * Decryption: it's the same algorithm, but the key schedule is in reversed order. 
 * @author Andreea Rindasu
 *
 */
public class Des {

	/**
	 * This is the main DES method .
	 * @param plaintextBit
	 * @param keyBit
	 * @param isDecrypt
	 * @return the encrypted or decrypted text
	 */
	public static int[] encryptDecrypt(int[] plaintextBit, int[] keyBit, boolean isDecrypt)
	{	
		// permutedPlaintextBits: stores the bits of plaintext permuted according to IP
		int permutedPlaintextBits[] = new int[plaintextBit.length];
		
		// permute the plaintext bits according to IP 
		for(int i = 0 ; i < plaintextBit.length; i++) 
		{
			permutedPlaintextBits[i] = plaintextBit[DesBoxes.IP[i] - 1];
		}
		
		// L: first 32 bits 
		int L[] = new int[32];
		// R: last 32 bits
		int R[] = new int[32];
		int i;
		
		// Having the key we need to discard the parity-check bits (8) and 
		// permute the remaining bits according to PC-1
		for(i = 0; i < 28; i++) 
		{
			// C: first 28 bits of PC-1(keyBit)
			KeySchedule.C[i] = keyBit[DesBoxes.PC1[i] - 1];
		}
		
		for( ; i < 56; i++) 
		{
			// D: last 28 bits of PC-1(keyBit)
			KeySchedule.D[i - 28] = keyBit[DesBoxes.PC1[i] - 1];
		}
		
		// split the permutedPlaintextBits into L0 and R0
		System.arraycopy(permutedPlaintextBits, 0, L, 0, 32);
		System.arraycopy(permutedPlaintextBits, 32, R, 0, 32);
				
			
		// Compute 16 iterations of Fiestel function
		for(int n = 0; n < 16; n++)
		{
			// fiestelR = the new R generated by Fiestel function
			int fiestelR[] = new int[0];
					
			// Decryption: stored subkeys are used in reversed order
			if(isDecrypt) 
			{
				fiestelR = FiestelFunction.fFunction(R, KeySchedule.subkey[15 - n]);
				System.out.print("Round key = " + n);
			}
			
			// Encryption: generate subkeys
			else 
			{
				fiestelR = FiestelFunction.fFunction(R, KeySchedule.keySchedule(n, keyBit));
				System.out.print("Round key = " + n);
			}
					
			// fiestelL = fiestelR XOR L
			int fiestelL[] = Utility.xorFunction(L, fiestelR);
			
			// fiestelL is stored in R, fiestelR is stored in L
			// swaping modified L and unmodified R for next round
			L = R;
			R = fiestelL;
			
			System.out.print("\nL = ");
			Utility.displayBits(L);
			System.out.print("R = ");
			Utility.displayBits(R);
		}
				
		// preoutput = R16 L16	
		int preoutput[] = new int[64];
		System.arraycopy(R, 0, preoutput, 0, 32);
		System.arraycopy(L, 0, preoutput, 32, 32);
				
		// and now we apply the inverse permutation to preoutput to optain ciphertext OR plaintext
		int result[] = new int[64];
		for(i = 0; i < 64; i++) 
		{
			result[i] = preoutput[DesBoxes.InverseP[i] - 1];
		}
				
		String hexResult = new String();	
		// convert the result to hex (it is array of bits)
		for(i = 0; i < 16; i++) 
		{
			// convert to 
			String binResult = new String();
					
			for(int j = 0; j < 4; j++) 
			{
				binResult += result[(4 * i) + j];
			}
					
			int decimalResult = Integer.parseInt(binResult, 2);
			hexResult += Integer.toHexString(decimalResult);
		}
				
		if(isDecrypt)
		{
			System.out.print("Decrypted text: ");		
		}
		
		else 
		{
			System.out.print("Encrypted text: ");
		}
				
		System.out.println(hexResult.toUpperCase());
		return result;
		}
	
}
