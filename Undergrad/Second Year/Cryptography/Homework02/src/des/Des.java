package des;

import main.Utility;

/**
 * A class describing DES.
 * DES is encrypting a plaintext bistring x of length 64 following an exact algorithm
 * -> Given a plaintext x, a bistring x0 is constructed by permuting the bits of x, according
 * to an initial permutation IP; x0 = IP(x) = L0 R0
 * 
 * -> 16 iterations of certain function Fiestel are computed. We compute LiRi ( i <= 16 ) according to:
 * Li = Ri-1 
 * Ri = Li-1 XOR f(Ri-1, Ki) 
 * 
 * -> Apply the inverse permutation IP-1 to bistring R16 L16 obtaining the ciphertext y;
 * y = IP-1 (R16 L16)
 * 
 * @author Andreea Rindasu
 *
 */
public class Des {

	public static int[] permute(int[] inputBits, int[] keyBits, boolean isDecrypt)
	{
		// Initial permutation step takes input bits and permutes into the newBits array
		/*
		 Given a plaintext inputBits, a bistring newBits is constructed by permuting the bits of inputBits
		 according to an initial permutation IP
		*/
		
		int newBits[] = new int[inputBits.length];
		
		for(int i = 0 ; i < inputBits.length; i++) 
		{
			newBits[i] = inputBits[DesBoxes.IP[i] - 1];
		}
		
		// subkeys for left and right
		/*
		 * L comprises the first 32 bits
		 * R comprises the lsat 32 bits 
		 */
		int L[] = new int[32];
		int R[] = new int[32];
		int i;
		
		/*
		 * Computation of the key schedule from key K:
		 * 
		 * K = bistring of length 64 of which 56 bits comprise the key and 8 bits are parity check bits 
		 * Given a 64 bit key K, discard the parity check bits and permute 
		 * the remaining bits of K according to a fixed permutation PK-1
		 * C : comprises the first 28 bits of PC-1(K)
		 * D : comprises the last 28 bits of PC-1(K)
		 * 
		 * PC-1(K) = C0 D0;
		 */
		
		// Permuted Choice 1
				for(i = 0; i < 28; i++) 
				{
					KeySchedule.C[i] = keyBits[DesBoxes.PC1[i] - 1];
				}
				for( ; i < 56; i++) 
				{
					KeySchedule.D[i - 28] = keyBits[DesBoxes.PC1[i] - 1];
				}
		
		// After PC-1 the first L and R are ready to be used 
		// initialize L0 and R0 
				
				// we put in newBits, starting to pos 0, L, from position 0 - 32 bits
				System.arraycopy(newBits, 0, L, 0, 32);
				// we put in newBits, starting to pos 32, R, from position 0 - 32 bits
				System.arraycopy(newBits, 32, R, 0, 32);
				
				/*
				 * System.out.print("\nL0 = "); displayBits(L);
				 * System.out.print("\nR0 = ");	displayBits(R);
				 */
				
				// 16 iterations of F function are computed:
				for(int n = 0; n < 16; n++)
				{
					/*
					 * newR = new R half generated by the Fiestel function
					 * for encryption Key Structure method is called to generate the subkey
					 * for decryption the stored subkeys are used in reverse order
					 */
					
					int newR[] = new int[0];
					
					// stored subkeys are used in reverse order for decryption
					if(isDecrypt) 
					{
						newR = FiestelFunction.fFunction(R, KeySchedule.subkey[15 - n]);
						System.out.print("Round key = " + n);
					}
					// call Key Structure to generate subkeys
					else 
					{
						newR = FiestelFunction.fFunction(R, KeySchedule.keySchedule(n, keyBits));
						System.out.print("Round key = " + n);
					}
					
					/*
					 * using XOR on L and newR gives us newL value
					 * newL value is stored in R and 
					 * newR value is stored in L, 
					 * exchanging R and L for the next round 
					 */
					
					int newL[] = Utility.xor(L, newR);
					L = R;
					R = newL;
					System.out.print("\nL = ");
					Utility.displayBits(L);
					System.out.print("R = ");
					Utility.displayBits(R);
				}
				
				// R and L has the two halves of the output before applying the final permutation		
				int output[] = new int[64];
				// copy in R from 0, output from 0 : 32 bits
				System.arraycopy(R, 0, output, 0, 32);
				// copy in L from 0 to output from 32 : 32 bits
				System.arraycopy(L, 0, output, 32, 32);
				
				int finalOutput[] = new int[64];
				/*
				 * Applying Inverse Permutation to the previous output, we get the final output:
				 * Encryption : final output is ciphertext
				 * Decryption : final output is plaintext
				 */
				for(i = 0; i < 64; i++) 
				{
					finalOutput[i] = output[DesBoxes.InverseP[i] - 1];
				}
				
				// Convert the final output to HEX string because it is int array of bits 
				String hex = new String();
				
				for(i = 0; i < 16; i++) 
				{
					String bin = new String();
					
					for(int j = 0; j < 4; j++) 
					{
						bin += finalOutput[(4 * i) + j];
					}
					
					int decimal = Integer.parseInt(bin, 2);
					hex += Integer.toHexString(decimal);
				}
				
				if(isDecrypt)
				{
					System.out.print("Decrypted text: ");
				
				}
				else 
				{
					System.out.print("Encrypted text: ");
				}
				
				System.out.println(hex.toUpperCase());
				return finalOutput;
			}
	
}
