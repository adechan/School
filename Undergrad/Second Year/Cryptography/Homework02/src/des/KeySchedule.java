package des;

/**
 * Computation of the key schedule from key K.
 * K = bistring of length 64 of which 56 bits comprise the key and 8 bits are parity-check bits 
 * Given a 64 bit key K, discard the parity-check bits and permute the remaining bits of K according to a permutation PC-1
 * PC-1 (K) = C0 D0
 * C0 : comprises the first 28 bits 
 * D0 : comprises the last 28 bits
 * 
 * From i: 1 to 16 compute: 
 * Ci = LSi(Ci-1) 
 * Di = LSi(Di-1)
 * Ki = PC-2(CiDi)
 * 
 * LSi: represents the cyclic shift to the left of either one or two positions depending on the value of i
 * 
 * Each round uses 48 bit key of the bits in K.
 * @author Andreea Rindasu
 *
 */
public class KeySchedule {

	// comprises the first 28 bits 
	public static int[] C = new int[28];
	// comprises the last 28 bits 
	public static int[] D = new int[28];
	
	// 16 subkeys
	// each round uses a 48-bit key comprised of 48 of the bits
	public static int[][] subkey = new int[16][48];
	
	/**
	 * 
	 * @param bits
	 * @param rotationValue
	 * @return each bit is rotated to the left and the leftmost bit is stored at 
	 * the rightmost bit. This is a left shift operation.
	 */
	public static int[] leftShift(int[] bits, int rotationValue) 
	{
		int result[] = new int[bits.length];
		
		// copies to bits to 0, from result, from 0: length of bits 
		System.arraycopy(bits, 0, result, 0, bits.length);
		
		for(int i = 0; i < rotationValue; i++) 
		{
			int temp = result[0];
			
			for(int j = 0; j < bits.length - 1; j++) 
			{
				result[j] = result[j + 1];
			}
			result[bits.length - 1] = temp;
		}
		return result;
	}
	
	/*
	 * Key Structure functions that generates the round keys
	 */
	/**
	 * 
	 * @param round
	 * @param key
	 * @return generates round key
	 */
	public static int[] keySchedule(int round, int[] key)
	{

		// new value of C that will be generated in this round 
		int C1[] = new int[28];
		// new value of D will be generated in this round 
		int D1[] = new int[28];
		
		// used to set how many rotations are need to be done 
		int rotationTimes = (int) DesBoxes.shiftPositions[round];
		
		C1 = leftShift(C, rotationTimes);
		D1 = leftShift(D, rotationTimes);
		
		// CnDn stores C1D1 to use in Kn
		int CnDn[] = new int[56];
		
		// copies in C1 to 0, from CnDn from 0: 28 bits
		// copies in D1 to 0, from CnDn from 28: 28 bits 
		System.arraycopy(C1, 0, CnDn, 0, 28);
		System.arraycopy(D1, 0, CnDn, 28, 28);
		
		// Kn stores the subkey generated by applying PC-2 table to CnDn
		int Kn[] = new int[48];
		
		// Ki = PC-2 (CiDi)
		for(int i = 0; i < Kn.length; i++) 
		{
			Kn[i] = CnDn[DesBoxes.PC2[i] - 1];
		}
		
		// store the subkey
		// store C1 and D1 in C and D
		// so this becomes old C and D for next round
		subkey[round] = Kn;
		C = C1;
		D = D1;
		return Kn;
	}
}
